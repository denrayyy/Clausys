import express from "express";
import multer from "multer";
import path from "path";
import { fileURLToPath } from "url";
import TimeIn from "../models/TimeIn.js";
import Classroom from "../models/Classroom.js";
import { body, validationResult } from "express-validator";
import { authenticateToken, requireTeacher } from "../middleware/auth.js";

const router = express.Router();

// Get __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadPath = path.join(__dirname, "../uploads/evidence");
    console.log("Upload destination:", uploadPath);
    cb(null, uploadPath);
  },
  filename: function (req, file, cb) {
    // Generate unique filename with timestamp
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, `evidence-${uniqueSuffix}${ext}`);
  }
});

// File filter for image uploads
const fileFilter = (req, file, cb) => {
  // Accept only image files
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Only image files are allowed!'), false);
  }
};

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  },
  fileFilter: fileFilter
});

// Error handling middleware for multer
const handleMulterError = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ message: 'File too large. Maximum size is 5MB.' });
    }
    return res.status(400).json({ message: err.message });
  } else if (err) {
    return res.status(400).json({ message: err.message });
  }
  next();
};

/**
 * @route   POST /api/timein
 * @desc    Create time-in record with evidence upload
 * @access  Private (Teacher only)
 * 
 * This endpoint allows teachers to submit their time-in with photographic evidence.
 * It automatically captures the current date and time, validates the uploaded image,
 * and stores the record in the database for admin verification.
 * 
 * Request Body:
 * - classroom: MongoDB ObjectId of the classroom (required)
 * - evidence: Image file upload (required, max 5MB, images only)
 * - remarks: Optional text remarks
 * 
 * Response:
 * - 201: Time-in record created successfully
 * - 400: Validation errors or missing required fields
 * - 401: Authentication required
 * - 403: Teacher role required
 * - 500: Server error
 */
router.post("/", authenticateToken, requireTeacher, upload.single('evidence'), handleMulterError, [
  body("classroom").isMongoId().withMessage("Valid classroom ID is required"),
  body("remarks").optional().isString()
], async (req, res) => {
  try {
    console.log("Time-in request received:", {
      body: req.body,
      file: req.file ? {
        filename: req.file.filename,
        originalname: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size
      } : null,
      user: req.user ? { id: req.user._id, role: req.user.role } : null
    });

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log("Validation errors:", errors.array());
      return res.status(400).json({ errors: errors.array() });
    }

    // Check if evidence file was uploaded
    if (!req.file) {
      console.log("No evidence file uploaded");
      return res.status(400).json({ message: "Evidence photo is required" });
    }

    const { classroom, remarks } = req.body;

    // Check if classroom exists
    const classroomExists = await Classroom.findById(classroom);
    if (!classroomExists) {
      return res.status(404).json({ message: "Classroom not found" });
    }

    // Check if there's already a time-in for this teacher today
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const existingTimeIn = await TimeIn.findOne({
      teacher: req.user._id,
      date: { $gte: today, $lt: tomorrow }
    });

    if (existingTimeIn) {
      return res.status(400).json({ message: "You have already timed in today" });
    }

    // Create time-in record with automatic timestamp and user data
    const timeInRecord = new TimeIn({
      teacher: req.user._id, // Automatically get teacher ID from JWT token
      classroom, // Selected classroom from dropdown
      evidence: {
        filename: req.file.filename, // Unique filename generated by multer
        originalName: req.file.originalname, // Original filename from user
        mimetype: req.file.mimetype, // MIME type for validation
        size: req.file.size, // File size in bytes
        path: req.file.path // Server file path for retrieval
      },
      timeIn: new Date(), // Current timestamp when time-in is submitted
      date: new Date(), // Current date for daily tracking
      remarks // Optional teacher remarks
    });

    await timeInRecord.save();
    await timeInRecord.populate("teacher", "firstName lastName email employeeId department");
    await timeInRecord.populate("classroom", "name location capacity");

    res.status(201).json({
      message: "Time-in successful",
      timeInRecord: {
        id: timeInRecord._id,
        teacher: timeInRecord.teacher,
        classroom: timeInRecord.classroom,
        roomNumber: timeInRecord.roomNumber,
        timeIn: timeInRecord.timeIn,
        date: timeInRecord.date,
        status: timeInRecord.status,
        remarks: timeInRecord.remarks,
        evidence: {
          filename: timeInRecord.evidence.filename,
          originalName: timeInRecord.evidence.originalName,
          mimetype: timeInRecord.evidence.mimetype,
          size: timeInRecord.evidence.size
        }
      }
    });
  } catch (error) {
    console.error("Time-in error:", error);
    console.error("Error details:", {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    res.status(500).json({ 
      message: "Server error during time-in",
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

/**
 * @route   GET /api/timein
 * @desc    Retrieve time-in records with filtering options
 * @access  Private (Teachers see only their records, Admins see all)
 * 
 * This endpoint fetches time-in records with optional filtering by:
 * - teacher: Filter by specific teacher ID
 * - classroom: Filter by specific classroom ID
 * - date: Filter by specific date
 * - status: Filter by verification status (pending, verified, rejected)
 * - startDate/endDate: Filter by date range
 * 
 * Teachers can only view their own records, while admins can view all records.
 * Results are sorted by date and time in descending order (newest first).
 */
router.get("/", authenticateToken, async (req, res) => {
  try {
    const { teacher, classroom, date, status, startDate, endDate } = req.query;
    let query = {};

    // If user is teacher, only show their time-in records
    if (req.user.role === "teacher") {
      query.teacher = req.user._id;
    }

    if (teacher) query.teacher = teacher;
    if (classroom) query.classroom = classroom;
    if (status) query.status = status;

    // Date filtering
    if (date) {
      const targetDate = new Date(date);
      const startOfDay = new Date(targetDate.setHours(0, 0, 0, 0));
      const endOfDay = new Date(targetDate.setHours(23, 59, 59, 999));
      query.date = { $gte: startOfDay, $lte: endOfDay };
    }

    if (startDate && endDate) {
      query.date = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }

    const timeInRecords = await TimeIn.find(query)
      .populate("teacher", "firstName lastName email employeeId department")
      .populate("classroom", "name location capacity")
      .populate("verifiedBy", "firstName lastName")
      .sort({ date: -1, timeIn: -1 });

    res.json(timeInRecords);
  } catch (error) {
    console.error("Get time-in records error:", error);
    res.status(500).json({ message: "Server error" });
  }
});

// @route   GET /api/timein/:id
// @desc    Get time-in record by ID
// @access  Private
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const timeInRecord = await TimeIn.findById(req.params.id)
      .populate("teacher", "firstName lastName email employeeId department")
      .populate("classroom", "name location capacity")
      .populate("verifiedBy", "firstName lastName");

    if (!timeInRecord) {
      return res.status(404).json({ message: "Time-in record not found" });
    }

    // Teachers can only view their own records
    if (req.user.role === "teacher" && timeInRecord.teacher._id.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }

    res.json(timeInRecord);
  } catch (error) {
    console.error("Get time-in record error:", error);
    res.status(500).json({ message: "Server error" });
  }
});

/**
 * @route   PUT /api/timein/:id/verify
 * @desc    Verify or reject time-in record (Admin only)
 * @access  Private (Admin role required)
 * 
 * This endpoint allows administrators to verify or reject teacher time-in records.
 * It updates the record status, records who verified it, and when it was verified.
 * This is crucial for maintaining accountability and ensuring proper attendance tracking.
 * 
 * Request Body:
 * - status: "verified" or "rejected" (required)
 * - remarks: Optional admin remarks about the verification
 * 
 * Response:
 * - 200: Verification status updated successfully
 * - 400: Invalid status or validation errors
 * - 401: Authentication required
 * - 403: Admin role required
 * - 404: Time-in record not found
 * - 500: Server error
 */
router.put("/:id/verify", authenticateToken, [
  body("status").isIn(["verified", "rejected"]).withMessage("Status must be verified or rejected"),
  body("remarks").optional().isString()
], async (req, res) => {
  try {
    // Check if user is admin
    if (req.user.role !== "admin") {
      return res.status(403).json({ message: "Access denied. Admin privileges required." });
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { status, remarks } = req.body;

    const timeInRecord = await TimeIn.findById(req.params.id);
    if (!timeInRecord) {
      return res.status(404).json({ message: "Time-in record not found" });
    }

    timeInRecord.status = status;
    timeInRecord.verifiedBy = req.user._id;
    timeInRecord.verifiedAt = new Date();
    if (remarks) timeInRecord.remarks = remarks;

    await timeInRecord.save();
    await timeInRecord.populate("teacher", "firstName lastName email employeeId department");
    await timeInRecord.populate("classroom", "name location capacity");
    await timeInRecord.populate("verifiedBy", "firstName lastName");

    res.json({
      message: `Time-in record ${status} successfully`,
      timeInRecord
    });
  } catch (error) {
    console.error("Verify time-in record error:", error);
    res.status(500).json({ message: "Server error" });
  }
});

// @route   GET /api/timein/evidence/:filename
// @desc    Get evidence image
// @access  Private
router.get("/evidence/:filename", authenticateToken, (req, res) => {
  try {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, "../uploads/evidence", filename);
    
    res.sendFile(filePath, (err) => {
      if (err) {
        console.error("Error sending file:", err);
        res.status(404).json({ message: "Evidence file not found" });
      }
    });
  } catch (error) {
    console.error("Get evidence error:", error);
    res.status(500).json({ message: "Server error" });
  }
});

export default router;
